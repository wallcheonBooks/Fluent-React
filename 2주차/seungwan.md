# Chapter3 가상 DOM

가상 DOM(Virtual DOM)이라고 하는 주제는 리액트를 처음 공부하게 되면 누구나 접하게 되는 주제다.
리액트에서는 렌더링이라는 개념이 굉장히 중요한데, 렌더링을 할 때 가상 DOM이라는 개념을 이용하기 때문에 잘 알아보도록 하자.

들어가기 전에 하나 알면 좋은 내용이 있다.
리액트에 많은 기여를 하고 있는 Dan Abramov는 VDOM이라는 표현을 폐기하기를 원한다고 했다. 그 이유는 아래와 같다.

virtual DOM은 React가 렌더링할 때마다 DOM을 생성하지 않는다는 점을 명확히 하기 위해 도입했지만 현재는 사용자들이 더 이상 그러한 오해를 하지 않으며 오히려 DOM의 이슈를 극복하기 위해 virtual DOM을 도입했다는 오해를 하고 있어 React의 의도와 다르게 해석되고 있기 때문이라고 한다. 대신에 UI를 값으로 다룬다는 의미에서 “value UI”라 표현하기를 권고한다.
React는 여러 환경에서 앱을 렌더할 수 있다. DOM 뿐만이 아니라, React Native에서도 사용되어 IOS, Android View에서도 그려지므로 Virtual "DOM" 이라는 표현 자체가 맞지 않는다.
React 공식문서에서도, 가상돔은 기술이라기보단 패턴에 가깝다고 설명한다.

따라서 개념적으로 VDOM이라고 표현하는 것은 좋으나, 지양하면 좋은 표현이라고 생각한다.
실제로 [공식문서](react.dev)에서 검색해보면 virtual dom, vdom 이라는 표현은 사용하지 않는다.

## 3.3 가상 DOM 작동 방식
(편의상 가상 DOM은 VDOM, 실제 DOM은 DOM이라고 표현하겠습니다)

VDOM은 DOM의 문제점을 해결하기 위해서 만든 자바스크립트 객체로 DOM을 모델링 한 것을 의미하는데,
엄밀히는 DOM의 문제점이라기 보다는 DOM을 다루면서 생길 수 있는 까다로운 부분들을 제어하기 위해서 만들어진 개념이라고 생각한다.

보통은 브라우저 렌더링 과정, 즉 Critical Rendering Path(CRP)에서 reflow, repaint 과정을 최적화하기 위해서 VDOM이라는 개념이 탄생했다고 생각하는데,
이 외에도 브라우저마다 다양한 DOM 구현의 차이를 추상화해서 일관된 API를 제공하는 역할도 하고 있다. VDOM이라고 하는 layer가 있기 때문에 실제 브라우저가 다른 방식으로 동작해도 문제가 생기지 않는다.

### 3.3.1 리액트 엘리먼트

DOM에 추가할 element를 만들 때는 document.createElement와 같은 API를 사용하듯이, 리액트에서 사용할 React Element를 만들 때는 React.createElement 함수를 사용해서 생성한다.
DOM -> document.createElement, VDOM -> React.createElement와 같은 개념이라고 생각할 수 있다.

리액트 엘리먼트를 콘솔에 찍어보면 아래와 같은 필드들을 볼 수 있습니다.

```javascript
const element = React.createElement(
  "div",
  { className: "my-class" },
  "Hellp, world!"
);

console.log(element);
{
  $$typeof: Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: {
    className: "my-class",
    children: "Hello, world!"
  },
  _owner: null,
  _stroe: {}
}
```

엘리먼트는 관련 prop이나 속성과 같이 리액트에서 ui를 표현하기 위해서 필요한 정보들을 담고 있는 자료 구조라고 볼 수 있습니다.

각 속성에 대해서 간단히 살펴보면,

- $$typeof: 객체가 유효한 리액트 엘리먼트인지 확인할 때 사용하는 특수한 심벌, XSS(Cross Site Scripting) 공격을 막기 위해서 사용하는 필드이기도 하며, 어떤 엘리먼트인지를 표현한다. (element fragment, portal, profiler, provider)
  
- type: 컴포넌트의 종류를 나타내는데 dom element일 수도 있고, 함수(함수 컴포넌트)일 수도 있다.
개발자가 작성한 리액트 컴포넌트가 렌더링되는 방식은 엘리먼트의 아래로 계속 탐색하며, 스칼라 값(숫자, 문자열, 불리언과 같이 더이상 분해되지 않는 값)을 만나면 텍스트 노드로 렌더링한다.

- ref: 기본 DOM 노드에 대한 참조, DOM을 직접 조작하는 경우에 필요하다.

- props: 컴포넌트에 전달되는 속성값, 함수에 전달하는 인수라고 생각하면 된다.

아래 두 값은 내부적으로 구현을 위해서만 사용하는 값이고, 서비스 코드에서는 사용하면 안된다.
- _owner: 누가 이 엘리먼트를 생성했는지
- _store: 엘리먼트에 대한 추가 데이터를 저장하기 위해

실제로 리액트는 VDOM 만으로 동작하는 것은 아니고, React Element들을 모아서 구성한 Fiber라는 아키텍처를 이용해서 ui를 값으로 표현하고 있다.
리액트는 16 버전부터 파이버라 불리는 새로운 코어 아키텍처를 채택했는데, 이는 기존의 스택 기반 알고리즘을 완전히 새롭게 작성하여 동시성과 관련됭 기능들을 다룰 수 있게 되었다.
Fiber는 아래와 같은 데이터들을 갖고 있다.

- 컴포넌트 트리에서, 이 시점에 렌더링되어야 하는 컴포넌트의 type
- 현재 컴포넌트와 연관된 props와 state
- 부모 컴포넌트, 형제 컴포넌트, 자식 컴포넌트를 향한 포인터
- React가 렌더링 과정에서 추적하기 위해 사용하는 다른 내부 메타데이터

### 3.3.2 가상 DOM과 실제 DOM 비교
리액트에서는 첫 렌더링(mount) 이후에 상태가 변경되면, 리렌더링이 발생하고 컴포넌트를 다시 실행해가면서 새로운 VDOM 트리를 구성한다.
이전 VDOM과 새로운 VDOM을 비교해서 이전 VOM을 새로운 VDOM과 일치하도록 업데이트 하기 위해서 필요한 변경 횟수를 계산한다.
이를 우리가 흔히 알고있는 재조정(reconciliation) 프로세스라고 한다.
(여기서 render phase와 commit phase를 구분해서 보면 좋은데, render 단계는 컴포넌트를 다시 실행하여 새로운 VDOM 트리를 구성하는 과정이며, commit 단계는 변경 지점을 확인하고 DOM에 반영하는 과정이다)

### 3.3.3 효율적인 업데이트
리렌더링의 조건이 무엇일까?
단순하게는 상태가 업데이트되면 트리거가 되어, 컴포넌트가 리렌더링이 된다.
또 하나 알아야 할 개념은, 부모 컴포넌트에 리렌더링이 일어나면 하위의 모든 자식 컴포넌트들에게 리렌더링이 일어난다.

앞에서 얘기했던 것처럼 리렌더링이 발생하면, 새로운 VDOM 트리를 구성하고 이전 VDOM과 새로운 VDOM을 비교하는데, 이때 어떤 방식으로 비교를 할까?
여기서 사용되는 알고리즘이 디핑(diffing) 알고리즘이라고 한다.

공식문서에 설명되어 있는 내용을 보면 시간복잡도를 알 수 있다.
```text
하나의 트리를 가지고 다른 트리로 변환하기 위한 최소한의 연산 수를 구하는 알고리즘 문제를 풀기 위한 일반적인 해결책들이 있습니다. 하지만 이러한 최첨단의 알고리즘도 n개의 엘리먼트가 있는 트리에 대해 O(n3)의 복잡도를 가집니다.

React에 이 알고리즘을 적용한다면, 1000개의 엘리먼트를 그리기 위해 10억 번의 비교 연산을 수행해야 합니다. 너무나도 비싼 연산이죠. React는 대신, 두 가지 가정을 기반하여 O(n) 복잡도의 휴리스틱 알고리즘을 구현했습니다.

서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.
```

디핑 알고리즘은 아래와 같이 작동한다.
1. 노드를 비교한다.
2. 노드가 같다면, 속성을 비교한다.
3. 자식 노드가 다른 경우, 변경된 자식 노드만 업데이트한다.
4. 노드의 자식은 동일하지만 순서만 변경된(key) 경우, DOM에서 노드의 순서를 다시 설정한다.
5. 트리에서 노드가 제거되면 DOM에서 노드를 제거한다.
6. 트리에 새 노드가 추가되면 실제 DOM에 추가한다.
7. 노드의 종류(type, div -> span)가 변경된 경우 이전 노드를 제거하고 새 노드를 생성한다.
8. 노드에 key prop이 있다면, 이 값을 이용해 노드의 교체가 필요한지 파악한다.

리액트에서 렌더링은 ui의 불일치를 해결하기 위해 적절한 수단이지만, 그로 인해 불필요한 리렌더링이 발생한다는 문제를 빼놓을 수 없다.
컴포넌트 상태가 변경되면 컴포넌트와 모든 자손 컴포넌트를 리렌더링 하기 때문이다.
(그 이유는 컴포넌트가 어느 상태에 종속되는지 알지 못하기 때문에 UI의 일관성을 유지하기 위해 모든 컴포넌트를 리렌더링 하는데, 이걸 해결한 프레임워크가 Signal 방식(fine-grained(미세한 단위의) 반응성)을 통해 해결하려고 한다)

이때 하위 컴포넌트의 렌더링 비용이 큰 경우에는 문제가 될 수 있다. 이런 경우에 렌더링 최적화가 필요한데, 무조건 useCallback, useMemo, memo가 정답은 아니다.
상태를 하위로 내릴 수도 있으며, 컴포넌트를 합성하는 방식으로 다룰 수도 있기 때문에 다양한 관점에서 렌더링 최적화 전략을 가져가는 게 필요하다.

## 3.4 돌아보기
웹 애플리케이션을 만들 때 겪는 어려움들
- 느린 렌더링 시간
- 브라우저 간 호환성

이를 VDOM을 조작하는 방식으로 해결하려고 한다.
VDOM은 리액트가 자바스크립트 객체로 메모리상에 DOM을 표현하는 방식이고, 필요한 업데이트 횟수를 최소화해 성능을 개선한다.
디핑 알고리즘의 특성상 불필요한 리렌더링이 발생하게 되는데, 리렌더링의 비용 자체는 비싸지 않기 때문에 메모이제이션을 하는 행위는 적절한지 고려해야하고, 무거운 계산을 비효율적으로 하고 있지는 않은지 확인하는 것도 필요하다.

## 3.5 복습하기
- DOM이란 무엇이며, 가상 DOM과는 어떻게 다른가?
- 문서 조각이란 무엇이며, 리액트의 가상 DOM과 어떤 점에서 비슷하고 다른가?
- DOM에서 문제가 되는 부분은 무엇인가?
- UI를 더 빠르게 업데이트 하는 데 가상 DOM이 어떻게 활용되는가?
- 리액트의 렌더링은 어떻게 동작하고, 어떤 문제가 발생할 수 있는가?

## 3.6 미리보기
