# React.memo

- Memoization(메모화): CS에서 이전에 계산된 결과를 캐싱해서 함수의 성능을 최적화 하는 기법
  - 구현 기반의 코딩테스트에서 페이지네이션에 따른 API 연동 시 캐싱을 하는 기법도 종종 나온다.
  - 자료구조/알고리즘 기반의 코딩테스트에서 LRU 캐시 처리, 피보나치 수열 재귀 최적화 등에서도 나올 수 있다.
  - 기술 면접에서도 캐싱 관련해서 개발 경험 등을 묻곤 한다.
- 메모화는 함수의 순수성을 필요로 함
  - 순수 함수: 동일한 입력에 대해 동일한 출력이 나와야 함
- 렌더링한다
  - 함수 컴포넌트를 호출한다
  - JSX가 반환된다
  - JSX는 리액트 엘리먼트로 변환된다
  - 리액트 엘리먼트는 결국 파이버 라는 노드들로 구성된 트리이다
  - VDOM이 구성되고 재조정이 이루어지며 실제 DOM에 반영된다
- 리액트 컴포넌트: 재조정을 위해 호출되는 함수
- 부모 컴포넌트가 리렌더링 되면 하위 자식 컴포넌트도 모두 리렌더링됨
  - 만약 상태가 부모에 있지 않고 형제 컴포넌트끼리 내부에 상태 있는 것은 서로 영향을 주지 않음
- 리액트에서는 함수 컴포넌트에 React.memo를 사용해 메모화할 수 있음
  - 프롭이 변경되었을 때만 리렌더링됨. 프롭에 변경되지 않는 한 재조정 과정에서 다시 호출되지 않음
  - 프롭에 얕은 비교를 수행해서 프롭의 변경 여부 확인
  - 스칼라(원시) 타입
  - 프롭이 다르면 컴포넌트가 메모화되지 않음
  - 프롭이 만약 스칼라가 아닌 참조 타입의 경우에는 얕은 비교로 인해 불필요한 리렌더링이 발생할 수 있어 부모 컴포넌트에서 해당 프롭에 대해 useMemo/Callback로 별도 메모화 시키기
    - 배열이나 객체 같은 것은 useMemo로 메모화
    - 함수는 useCallback으로 메모화
  - 하지만 컴포넌트 트리 상태 변경, 전역 상태 변경 등의 영향으로 항상 메모화되지는 않음
- 개인 실제 활용 사례
  - 어드민에 대시보드 단일 페이지로 많은 차트들이 들어가 있는 테이블이 렌더링되고 있음
  - 불필요한 리렌더링으로 인해 성능 부하가 발생
  - 차트 컴포넌트를 React.memo로 wrapping해서 성능 이슈 해결

# useMemo

- 컴포넌트 내부의 특정 계산을 메모화해 비용이 많이 드는 재계산을 피하고 결과에 대한 일관된 참조 유지
- 스칼라(원시) 타입은 대체로 useMemo 사용할 필요 없음
- 이벤트 핸들러를 useCallback으로 꼭 메모화를 해야할까?? -> 아니오
  - 직접 전달
  - 렌더링 동작
  - 함수에 대한 가상 DOM 비교하지 않음
  - 이벤티 풀링
- useCallback 유용성
  - 자식 컴포넌트의 렌더링 비용이 비싸서 렌더링 횟수를 줄여 성능 최적화 할 때 콜백 함수를 메모화해서 넘길 때 사용 가능
- useMemo 유용성
  - 정렬된 배열 값
  - today 같이 변하지 않는 부분
