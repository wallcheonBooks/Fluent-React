# Chapter1. 입문자를 위한 지식

- 보통 리액트 책을 보면 1장, 2장과 같이 초반에는 배경지식이나 JavaScript 지식을 설명하는 편인데, 여기서는 어떤 내용을 설명할지 궁금했음.
- 조금 읽어보면 리액트가 왜 존재하는지, 어떻게 동작하는지, 어떤 문제를 해결하는지 등등 리액트의 배경에 대해서 설명을 하는 부분인데, 이는 내가 기술을 학습할 때 중요하다고 생각하는 부분에 속한다.
  - A라는 기술이
    - 어떤 문제를 해결하는지
    - 어떤 상황에 쓰는지
    - 어떤 장/단점이 있는지
    - 대채제는 없는지
- 그래서 좋은 챕터라는 생각이 들었음. 솔직히 신입~주니어 레벨에서 무지성으로 기술을 다루는 사람이 널린듯

- **Q. 라이브러리나 프레임워크 개발자 수준으로 리액트를 이해할 수 있게 돕는다고 하는데 이게 정말 필요할까?**

  - 많은 리액트 책이 최종 사용자(사실상 리액트를 이용해서 비즈니스 문제를 해결하는 사람들 이라고 생각함)로서 리액트를 사용하는 방법에 집중한다고 하는데... 사실 충분히 이 관점도 좋다고 생각함.
  - 당연한 얘기지만 모두가 업계에서 높은 자리에 오르는건 불가능함. 이미 지금도 1~2%의 천재들이 나머지 98~99%의 인원들을 이끌고 생태계를 만들어 나가고 있음. 그리고 애초에 노력을 하는 정도와 재능의 차이가 있기 때문에 일부만 가능하다고 생각함
  - 개인적으로는 프로덕트 개발자로서 비즈니스 문제를 해결하는 데 있어서 리액트를 문제없이 쓰는 정도면 충분하다고 생각함... 모두가 대기업에 가고 플랫폼 개발자가 되고 오픈소스를 개발하고 할 필요는 없음.
  - 그래서 결론적으로는 로우레벨이나 딥다이브에 너무 집착할 필요는 없는 것 같음... 알면 당연히 좋지만 그걸 알아가는 비용과, 그로 인해서 나의 퍼포먼스가 얼마나 향상되는지를 비교해보면 적어도 프로덕트 개발자라면 생산성이 그렇게 올라갈 것 같지는 않음. 차라리 NEXTSTEP의 클린코드 교육을 듣는 게(내가 작성한 코드를 대기업 개발자한테 리뷰받는 것) 생산성이 훨씬 올라갈 것 같음.
  - 물론 당연히 좋긴 한데~~~ 개개인 취향에 따라 갈리는 영역인 것 같기도 함... 솔직히 쓰는 쪽을 생각하면 내부 동작에 딥다이브 하는 것 보다는 클린 코드나 클린 아키텍처와 같은 관점으로 시스템 설계에 집중하는 게 더 효율적인 것 같음.
  - 그렇다면 "나는 어떤 생각을 갖고 있는가?"라고 한다면 솔직히 잘 모르겠음... 물론 일반적인 사람들보다는 일과 개발에 흥미를 느끼는 사람이라고 생각하고 객관적으로 평균보다 역량이 좋다고 생각함. 근데 그 상위 레벨에서도 상위로 가고 싶은지는 잘 모르겠음... 지금은 조금 개인적으로 과도기에 있는 것 같음. 왜냐면 내 개발자로서의 목표는 솔직히 네카라쿠배당토였기 때문인데, 이번에 그걸 이루고 나니 잠깐 공허함이 찾아온 것 같음. 여기서 더 뛰어난 개발자가 되기 위해서 꾸준히 노력하고 공부할지, 이정도 수준에서 적당히 성장을 할지가 고민인 것 같음.

## 1.1 리액트는 왜 필요한가요?

- 업데이트 때문에 필요하다고 함. 업데이트가 뭔데? 라고 한다면 뒤에 나오겠지만 예전의 정적인 웹과는 다르게 이제는 웹이 정말 많은 일들을 하고 있음. 웹뷰를 통해서 수천만명이 사용하는 앱에도 웹 화면이 보여지고 있고 쇼핑몰, 주식, 코인등의 복잡한 서비스들도 웹으로 구현이 되어 있음. 이런 서비스들을 생각해보면 화면이 자주 바뀌는데 즉 이게 업데이트가 아닐까? 생각이 듬.
- 근데 그러면 기존에 업데이트를 하는 데 있어서 어려움이 있었으니까 리액트가 나온거겠지? 생각이 듬. 왜 어려웠을까? 간단한 웹이면 어려울 게 없을 것 같음. 그냥 DOM 1~2개 찾아서 변경하면 되니까. 근데 되게 복잡한 웹이면? 유즈케이스가 매우 많으면? 엣지케이스도 많으면? 코드가 진짜 개떡이 될 것 같음. 유지보수? 너무 지옥임.. 그러면 추상화를 하게 되겠지? 이 추상화를 잘 해놓은 것이 웹 프레임워크라고 볼 수 있을 것 같음.

- 책에서는 즉각적인 업데이트를 하고 싶었지만 다음과 같은 이유로 이게 어렵다고 얘기를 함
  - 성능, reflow를 얘기하는데, reflow는 브라우저 렌더링 과정에 있어서 비용이 가장 크다고 얘기를 함.
  - 신뢰성, 단어는 어렵게 느껴질 수 있을 것 같은데 그냥 데이터 추적이 잘 안된다는 것 같음. 이는 SSOT가 지켜지지 않거나, 혹은 해당 데이터에 접근하고 변경을 가하는 방식에 제약이 없기 때문에 그럴 것 같음. 이는 리액트를 사용하더라도 외부에 노출하는 인터페이스를 제한해주지 않으면 똑같이 생길 수 있는 문제이기는 함. (그러나 단방향 데이터 흐름을 통해서 진짜 드럽게 짜도 덜 드럽게 보이게끔은 해줌)
  - 보안, XSS, CSRF와 같은 문제를 얘기하는데 리액트의 경우에는 React Element에 보면 JavaScript의 Symbol을 활용한 $$typeof 라고 하는 프로퍼티가 있는데 이 프로퍼티가 없으면 리액트는 렌더링을 거부함. 근데 XSS, CSRF와 같은 공격은 JSON 형태로 보통 들어오는데 직렬화되어야 하는 상황에서는 Symbol같은 것이 존재할 수 없기 때문에 React 팀에서는 React Element 구조를 설계할 때 이런 아이디어를 낸 것 같음.
    - 이런 아이디어는 어떻게 생각해냈을까? 처음 생각은 XSS, CSRF를 어떻게 막을까에서 시작했을 것 같음. 그러면 해당 공격의 특성을 생각해 봤을 것이고, 외부에서 주입된 것과 메모리상에서(?) 만들어내는 무언가를 명확하게 구분짓는 방법에 대해서 고민해봤을 것 같음. 그리고나서 직렬화가 되지 않는 것들, 함수, Symbol 이런 걸 생각하지 않았을까? -> 물론 이는 모두 상상이지만 문제를 해결 할 때 이런 식으로 순차적으로 접근해보는 것이 중요한 것 같고 이런 과정에서 CS나 관련된 지식이 얼마나 있냐에 따라서 생각하는 깊이가 달라지는 것 같음.
  - Vanilla JavaScript로 버튼을 제어하는 예제를 보여주는데 일단 여기서 전제는 데이터라고 하는 것을 DOM에 저장하는 방식으로 다루고 있음. 그냥 JS에서도 관리할 수 있을탠데 일부러 더 극적으로 비교하려고 DOM에 꽂은 것 같음. 근데 당연하겠지만 예제 코드에서는 추상화가 전혀 일어나지 않았기 때문에 복잡할 수 밖에 없음. 작업을 하면서 적절한 계층으로 분리하면서 작업한다면 너무 복잡한 것 까진 아니라고 생각.
  - 예전에는 프론트엔드 개발이라는 포지션이 없었고 서버에서 템플릿 엔진을 통해서 작업했다보니 사실 지금 예제에서 얘기하는 웹개발 방식과는 차이가 있었다고 생각함. 도메인 로직이 모두 서버에 있고, ViewModel을 거의 그대로 템플릿 엔진에 던져주고, 템플릿은 Presentation 계층의 역할만 했을테니?
  - 근데 당연히 복잡한 건 맞으니까 이 복잡도를 제어하기 위한 프레임워크들이 많이 탄생함.

### jQuery

- jQuery로 개발을 직접 해본 경험이 없기 때문에 잘 모르지만, 브라우저 초기 생태계에서 크로스 브라우징에 강점이 있었고, 그당시에 Web API를 그대로 사용하는 것 보다는 ajax라던지 DOM을 조작하는 API가 그래도 훨씬 괜찮았던 것 같음. 다만 이 라이브러리 자체는 웹을 구성하기 위한 아키텍처를 제안한다기 보다는, 단순히 한번 Web API를 한번 래핑해놓은, 더 선언적으로 쓸 수 있는 정도의 기술이 아니었나 싶음. 그래서 이렇게로는 복잡도를 관리할 수 없기 때문에 새로운 니즈가 생기고 자연스럽게 사라지는 것 같음.

### Backbone

- Backbone은 많이 들어봤음. 그리고 실제로 개발도 해보고 싶었는데 사실 공식문서를 봐도 뭔가 쫌 그렇긴 했음. 잘모르겠음. 전통적인 MVC 패턴을 자체적으로 해석해서 녹여냈다고 소개하고 있는데 MVC 패턴은 우선 공부하기에 되게 좋은 것 같다고 생각함. 프로그램을 개발할 때 계층을 구분짓는 것은 여러 관점에서 되게 중요한데 이를 직접 느낄 수 있기 때문에.
- 개인적으로 이해했던 방식은 Model은 데이터, 비즈니스 로직을 다루고 View는 UI를 구성한다. 그리고 컨트롤러는 Model과 View 사이에서 Model에 변경이 생기면 그걸 View에 전달하기도 하고, View에서 이벤트가 발생하면 그걸 Model에 전달하기도 한다고 이해하고 있다. 중요한 건 Model과 View는 서로 몰라야 한다는 것이다. 근데 이 부분을 처음에 되게 이해하기 어려워 하는 것 같다. 서로 모른다? 라는 게 일반적인 개념에서는 납득이 잘 안되기 때문이다. 예를 들어서 쇼핑몰을 개발한다고 했을 때 Model은 상품 데이터를 관리하고, View는 상품 데이터를 화면에 보여줄탠데 책임이 이렇다고 할 때 Model과 View가 서로를 모르는게 어떻게 말이 되냐? 라는 것이다. 근데 여기서 모른다고 하는 것은... 사실 직접 참조를 하지 않는 것이라고 생각한다. Model의 입장에서는 View가 상품을 어떻게 보여줄지에 대해서는 관심이 없고 상품 데이터를 잘 관리하고 가공하는 것에만 관심이 있다. 그리고 View는 데이터를 어떻게 만들던, 어디에서 가져오든 이런 건 전혀 상관이 없고 내가 화면에 보여줄 상품이라는 데이터만 받을 수 있으면 된다. 이런걸 서로 모른다고 한다.
- MVC 패턴은 장점이 있는데 아래와 같다.
  - 인지 부하 감소 → 가독성 향상 → 유지보수성 증가
  - 응집성 증가, 결합도 감소, 재사용성 증가
  - 테스트 가능성 증가
- 사실 전통적인 관심사의 분리(Separation of Concerns, SoC)라고 볼 수 있다. 커다란 프로그램을 하나의 덩어리로 인식하면, 코드를 작성하기도 어렵고, 읽고 이해하기도 어렵다. 관심사에 따라 모듈화, 캡슐화를 하는게 좋다.
- MVC는 당연히 단점도 있는데 서비스가 복잡해지면 Controller가 진짜 비대해진다. 물론 잘 분리를 해야겠지만.. 그리고 하나의 View가 여러개의 Model에 동시에 의존한다던지, 여러개의 View가 하나의 Model에 의존한다던지 하면 이 의존 관계가 너무 복잡해진다. 프로그램이 어떻게 동작할지 예상하기가 어렵다.
- Backbone의 단점으로 여러개를 얘기하는데 보일러플레이트 코드가 많다는 것은 항상 개발자가 불편하게 느끼는 것중에 하나인 것 같다. Redux도 그랬고 결국 생산성이 중요하기 때문인 것 같음. 그리고 복잡하기도 하고. 그리고 UI를 조합하는 방식이 어렵다.

### knockout

- reactive 자바스크립트 라이브러리라고 얘기하는데, 좋은 패러다임인 것 같음. 옵저버블은 데이터의 출처이고, 바인딩은 해당 데이터를 소비하고 렌더링하는 사용자 인터페이스. 옵저버블은 모델, 바인딩은 뷰와 비슷한 개념이다.
- 여기서 MVVM 패턴을 언급하는데 View-Model이 요즘은 꽤 중요한 것 같다. 서버의 Entity와 클라이언트에서 다루고자 하는 데이터는 대부분 다르기 때문이다. 그리고 ViewModel 계층을 만드는 것이 View를 변화로부터 격리할 수 있어서 되게 유용하다고 생각함. 실제로 많은 회사들에서도 사용하고 있고 이름은 회사 스타일마다 조금씩 다른 것 같음. serializer, model, WebEntity 등등
- MVVM에서 View는 수동적인데, 애플리케이션 로직은 포함하지 않고 ViewModel이 전달해주는 데이터만 자동으로 반영한다. 선언적으로 뷰 모델이 바인딩함. View 입장에서는 나는 A라는 ViewModel에 바인딩할래, 구독할래 요런 느낌으로 보면 될 것 같음.
- ViewModel은 바인딩할 데이터와 명령을 제공한다. 이는 리액트로 생각해보면 커스텀 훅이라고 볼 수 있음. 혹은 Fetcher 컴포넌트 일 수도 있고 Container 일 수도 있다. 결국 ViewModel과 같은 일을 하고 싶은 것이고, 그 형태가 어떻게 드러나는지에 따라 달라지는 것 같다. 모델의 데이터를 뷰에서 쉽게 표현할 수 있는 형식으로 변환하는 일도 하는데 이와 관련한 작업을 클라이언트, 서버중에 어디서 해야하는가? 에 대해서 항상 다양한 의견이 존재하는 것 같다. 내 생각에는 기본적으로는 UI와 관련된 로직이고, 다양한 플랫폼(Web, App, Desktop)에 적용해야 한다던가 하는 상황이 일반적이다보니 클라이언트에서 들고 있는 게 괜찮을 것 같다. 혹은 BFF로 계층을 하나 더 분리하던지? 그런데 서버에서 조합을 해서 뷰에서 표시할 데이터를 만들어주는 게 더 적절한 경우도 있다. 리걸 이슈로 클라이언트에서 특정 값을 들고 있을 수 없다던지, 혹은 해당 데이터를 만들기 위해서 복잡한 도메인 로직이 필요한 경우라고 생각한다.
- ViewModel은 또한 테스트가 용이하고, 재사용성이 좋다라고 얘기하는데 결국 순수 함수처럼 동작하다보니 테스트가 용이하다고 볼 수 있는 것 같다. A라는 데이터를 받아서 B로 변환해주고, View의 입장에서는 A라는 행위를 하기 위해서 Model에 직접 접근하는 것이 아니라 ViewModel을 통해서 접근하다보니, 이런 함수는 일반적으로 input, output이 명확한 편이다.
- MVC, MVVM 패턴의 실제 차이점은 결합과 바인딩이라는 것을 알 수 있는데 컨트롤러가 없는 경우에는 데이터 소유권이 더 명확하고 사용자에게 더 가까이 있다. 리액트의 경우에는 단방향 데이터 흐름을 가지다보니 데이터 소유권이 더욱 제한되는데 상태가 필요한 특정 컴포넌트가 상태를 소유하는 것을 의미한다. (응집도가 굉장히 높다는 뜻)
- knockout의 코드를 보면서 html의 data-bind 구문을 봤는데 이렇게 동작하려면 eval 써야할 것 같은데? 라는 생각이 들었는데 찾아보니까 eval은 아니지만, Function의 Constructor를 이용해서 eval과 비슷하게 동작하게끔 하는 것 같다. 요런 상황에서 느끼는게 그래도 스스로 생각하는 힘이 조금 길러지고 있다는 느낌을 받는 것 같음.
- knockout도 여전히 보일러플레이트 코드가 굉장히 많고, 서비스가 복잡해지면 유지보수하기 어려워진다. 리액트또한 코드는 정말 복잡하지만, 이를 내부에 숨겨놓은 추상화 방식이 굉장히 좋은 접근인 것 같다.

### 앵귤러JS

- 양방향 데이터 바인딩은 Model 변경하면 View도 반영되고, View 변경하면 Model도 반영되는 방식인데 이는 되게 강력하지만, 항상 트레이드 오프가 있듯이 데이터의 흐름을 파악하고 유지보수 하는 것에 있어서 굉장히 어려움이 있는 접근이라고 생각한다. 개발을 하면서 느낀 점은 결국 제품이 성장함에 따라서 생산성을 꾸준히 유지할 수 있는 게 중요한 것 같은데 이 관점에서 양방향 데이터 바인딩은 문제가 있는 것 같다.
- 모듈식 아키텍처는 굉장히 좋다고 생각하고 의존성 주입도 너무 좋은데 러닝 커브가 좀 높은 것 같기는 함. 의존성 주입(DI)은 정말 중요한 개념이라고 생각한다.

## 리액트 등장

- 리액트는 JSX와 훨씬 간단한 컴포넌트 모델을 도입했다.
- 또한 단방향 데이터 흐름 패턴을 도입하여 데이터가 어떻게 변화하는지 더 쉽게 이해할 수 있게 했다.
- 가상 DOM을 사용하면서 업데이트를 한번에 처리하여 reflow와 같은 렌더링 과정을 최소화하여 성능에 이점을 가져갔다.
- 뷰와 모델을 훨씬 쉽게 동기화 할 수 있는 방법을 고민했고, 이에 대한 고민으로 리액트와 같은 도구를 페이스북 팀에서 개발하고 오픈소스로 공개했다.

### 선언적 코드와 명령형 코드

- 선언적이라는 표현은 우리가 하고 싶은 것을 표현하는 것이다.
- 가능하면 선언적으로 코드를 작성하는 것이 가장 좋다.

### 가상 DOM

- VDOM은 결국의 DOM을 값으로 표현한 것이다.
- Fiber 아키텍처를 이용해서 값으로 UI를 표현한다. Fiber는 기존에는 스택 구조였지만 트리 구조로 변경되면서 동시성 기능을 다룰 수 있게 되었다.

### 컴포넌트 모델

- 리액트 팀은 전통적인 관심사의 분리가 아닌 컴포넌트라는 단위로 관심사의 분리를 더욱 효과적으로 표현한 것 같다.

### 불변 상태

- 리액트에서는 상태를 불변으로 다뤄야하는데 이는 일단 근본적으로는 diffing 알고리즘 때문이다. 그리고 불변으로 다루면서 안정적이고, time travel과 같은 이점을 누릴 수 있다.

### 플럭스 아키텍처

- 결국 단방향 데이터 흐름을 구조화, 추상화 한 것
- 프로그램에서는 데이터를 잘 다루는 것이 절말 중요한데, 단방향 데이터 흐름이 이를 위한 하나의 방법이라고 생각한다.
