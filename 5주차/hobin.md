# 호빈

## useTransition의 동작 원리

`useTransition`은 React에서 우선순위가 낮은 업데이트를 지연하여, 중요한 사용자 인터랙션에 대한 UI 반응성을 높이기 위한 훅이다.

```javascript
const [isPending, startTransition] = useTransition();

startTransition(() => {
  setList(filteredList);
});
```

### 동작 흐름

1. `startTransition()`을 호출하면, React는 내부적으로 `isPending = true` 상태를 **동기적(SyncLane)** 으로 설정.
2. `startTransition()` 내부의 상태 변경은 **TransitionLane** 으로 예약.
3. 지연된 업데이트가 커밋되면 `isPending = false`로 다시 업데이트.

이때 `isPending === true`인 동안 화면에는 이전 상태(`list`)가 그대로 남아 있게 되며, 이는 React가 transition이 끝날 때까지 기존 UI를 유지하도록 설계한 것이다. 다른말로 커밋 전까지 이전 상태의 스냅샷이 보인다고 할 수 있다.

## flushSync의 동작 원리

`flushSync()`는 React에서 모든 SyncLane 업데이트를 **즉시 처리**하도록 강제하는 함수다.

```javascript
flushSync(() => {
  setFlag(true);
});
```

### 동작 흐름

1. flushSync가 실행되면, 그 시점에서의 **모든 SyncLane 업데이트**가 즉시 render + commit.
2. `flushSync()` 내부의 업데이트뿐 아니라 **flushSync 전에 예약된 SyncLane 작업도 함께 처리**.

### 주의사항

**SyncLane 업데이트만 앞당겨서 커밋**까지 해주는 것이다. 다른 레인에 영향을 주는 것이 아님.

## flushSync와 useTransition을 함께 사용할 때의 주의사항

다음과 같은 **특정 상황**에서만 사용자 입장에서 **화면의 상태 변화가 어색하게 보일 수 있다.**

- `flushSync`를 **여러 번 나눠 호출**한 경우
- `startTransition`을 **여러 번 나눠 호출**하여 각각이 **다른 batch로 처리**되는 경우

이처럼 `flushSync`나 `startTransition`을 **분산 호출**하면, 상태 반영이 쪼개져 일어나기 때문에 **UI가 들쑥날쑥하게 변해 보일 수 있다.**

> 결국 **중간 상태의 스냅샷이 사용자에게 노출되는 것**이 문제의 핵심이다.

### flushSync를 여러 번 나눠 호출한 경우

- 각 상태 변경이 **즉시 렌더링 + 커밋**되기 때문에, 상태 변화가 **순차적으로 화면에 드러남**
- 이로 인해 자연스럽게 이어져야 할 UI 흐름이 **계단식으로 나타나며 어색하게 보일 수 있음**
- 또한 flushSync는 **동기 렌더링을 강제**하기 때문에, 우선순위가 낮은 transition 업데이트는 **뒤로 밀리게 됨**

### startTransition을 여러 번 나눠 호출한 경우

- 각 `startTransition()` 호출은 **별개의 transition으로 인식**되어 batch 처리되지 않음
- 그 결과, 서로 관련된 상태 업데이트임에도 **시간차를 두고 화면에 반영**될 수 있음
- 사용자 입장에서는 **UI가 순차적으로 어색하게 바뀌는 것처럼 보일 수 있음**

## useDeferredValue

**`useDeferredValue`**는 상태 값을 지연시키는 데 특화된 훅이다. 내부적으로 **`startTransition`**을 사용한다고 유추할 수 있다.

사용자가 즉각적으로 입력하는 값에 의해 파생되는 여러 상태 변경들이 렌더링 성능을 저하시킬 수 있다. 이때, **`useDeferredValue`**를 사용하여 렌더링을 지연시켜 **성능을 최적화**할 수 있다.

**디바운스**나 **쓰로틀링**과의 차이점은, 디바운스와 쓰로틀링은 **시간 간격**을 명시적으로 설정해야 하는 반면, **`useDeferredValue`**는 **React**에게 **렌더링 우선순위를 낮추라고 선언적으로 지시할 수** 있다는 점이다. 이 훅은 내부적으로 **Transition Lane**에 상태 업데이트를 예약하여 덜 중요한 작업을 **비동기적으로 처리**한다.

## 티어링

React에서 **동시성 렌더링**이 도입되면서 각 컴포넌트의 **렌더와 커밋 시점이 달라질 수 있게** 되었다.
 이로 인해 렌더링 도중 상태가 변경되면, **동일한 상태를 참조하던 컴포넌트들조차 서로 다른 값을 표시**하는 현상이 발생할 수 있다.

이러한 **상태 불일치 현상**을 **티어링(tearing)**이라고 한다.

티어링은 React가 동시성 렌더링을 도입함으로써 **구조적으로 피할 수 없는 문제**다.

티어링 현상은... 

- **렌더링 비용이 큰 컴포넌트**에서 더욱 뚜렷하게 드러난다. (렌더링이 빠르면 중간 상태가 눈에 띄지 않음)
- **React 내부 상태**를 사용할 경우에도 티어링은 발생할 수 있지만,
   결국 React가 렌더링을 다시 조정하면서 **최종 상태로 수렴**한다.
   => 중간 스냅샷이 눈에 보이는 현상일 뿐이다.

## `useSyncExternalStore`를 통한 해결과 한계

`useSyncExternalStore`는 React 외부 상태와의 **정합성을 유지**하기 위한 전용 훅이다.
이 훅은 외부 상태의 변화에 React가 **즉시 반응할 수 있도록 구독**하고, 렌더링 도중 불일치가 발생하면 이를 **자동으로 무효화하고 재렌더링**한다.

### 작동 방식

1. React는 `getSnapshot()`으로 현재 상태(v1)를 읽음
2. 렌더링 중 외부 상태가 v2로 변경됨
3. `subscribe()`가 변경을 감지해 React에 알림
4. React가 `getSnapshot()`을 다시 호출 → v2 확인
5. **렌더링을 무효화하고, 최신 상태로 재렌더링**

=> 이렇게 **렌더 중 발생한 외부 상태 변화로 인한 티어링을 방지**할 수 있다.

### 한계점

`useSyncExternalStore`는 어디까지나 **React 외부 상태의 일관성 문제**를 해결하기 위한 도구일 뿐이다.
 **React 내부 상태를 사용하는 경우**의 티어링은 여전히 발생할 수 있으며, `useSyncExternalStore`로는 해결할 수 없다.

### 그렇다면 리액트 내부의 상태를 써서 발생하는 티어링 문제는 어떻게 해결해야할까?

> 내부 상태에서의 티어링은 **완전히 막을 수 있는 방법은 없고**, 대신 **노출을 최소화하는 전략**이 필요하다.

### 대표적인 회피 전략

- **`startTransition()`**: 상태 업데이트를 낮은 우선순위로 처리
- **`useDeferredValue()`**: 값의 업데이트를 지연시켜 렌더 우선순위 조정
- **`flushSync()`**: 동기적으로 즉시 반영 (단, 제한적으로 사용해야 함)
- **렌더 비용 최적화**: `React.memo`, `useMemo` 등을 활용해 느린 렌더링을 최소화
- **상태 분리**: 자주 바뀌는 값과 비싼 컴포넌트를 독립적으로 구성
