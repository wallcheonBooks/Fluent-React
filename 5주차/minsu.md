# 리액트 서버 컴포넌트

- RSC는 리액트 애플리케이션의 성능, 효율성, 사용자 경험을 개선하기 위해 설계됨
- 클라이언트 JS 번들에 포함되지 않음
- 빌드 시점에 실행될 수 있음
- 리액트 컴포넌트는 리액트 엘리먼트를 반환하는 함수일뿐
  - 리액트 컴포넌트는 JSX 반환
  - JSX는 ReactElement(JS 객체)로 변환됨
- 장점
  - 서버에서 실행되어 성능 더 잘 예측 가능
  - 토큰과 같은 민감한 정보가 유출될 걱정 없음
  - 비동기로 동작 가능
- 서버 렌더링
  - RSC 렌더러: 서버 컴포넌트를 리액트 엘리먼트로 렌더링하는 프로세스
  - Server 렌더러: 리액트 엘리먼트를 HTML 문자열이나 스트림으로 렌더링하는 프로세스 (직렬화)
  - 내부 구조
    - 리액트는 클라이언트/서버에서 모두 문자열, 숫자, 불리언 값 이해하고 렌더링 가능
    - 배열의 경우는 각 자식에 대해 재귀적으로 함수를 호출해 처리함
    - 객체
      - 리액트 엘리먼트
        - 내장 컴포넌트: jsx.type은 string
        - 사용자가 작성한 리액트 컴포넌트: jsx.type은 function
      - 임의의 객체
  - 직렬화
    - 리액트 엘리먼트를 문자열로 변환하는 과정
    - 중요성
      - 서버가 즉시 표시할 수 있는 완전한 HTML 페이지를 빠르게 클라이언트에 전송 가능 -> 페이지 체감 로딩 속도 개선
      - 환경에 관계없이 일관되고 예측 가능한 초기 렌더링 가능 -> 레이아웃 시프트나 깜빡임 방지
      - 클라이언트 사이드의 하이드레이션 프로세스 용이하게 함
  - 페이지 탐색
    - RSC를 사용하면 Soft Navigation 구현 가능
      - 페이지를 완전 새로고침하는 Hard Navigation과 달리 데이터만 불러와서 새 페이지 표시하는 방식
  - 업데이트
    - 서버 환경에서는 '상태'라는 개념이 여러 클라이언트에 걸쳐 공유됨, 함수는 직렬화 불가 (렌더 프롭 패턴 사용 불가)
    - 가능한 한 많은 코드를 서버에서만 렌더링하고 클라이언트 번들에서 제거하여 로딩 시간 감소하고 성능 향상
  - 내부 동작
    - 서버에서 클라이언트 컴포넌트를 위한 플레이스홀더를 렌더링함
      - 플레이스홀더: 클라이언트 번들러가 생성한 특정 모듈에 대한 참조
    - 번들러는 전체 트리를 서버에서 렌더링할 수 있음
    - Suspense로 서버 컴포넌트 래핑하면 서버 컴포넌트가 '준비'(데이터 fetch, 비동기 작업 모두 완료)될 때마다 스트리밍할 수 있음
  - 주의할 점
    - 클라이언트 컴포넌트도 서버에서 실행되고 리액트 엘리먼트를 나타내는 일부 객체를 반환한 후 서버가 이를 HTML로 직렬화해 클라이언트로 전송함
- 서버 컴포넌트 규칙
  - 직렬화 가능성이 가장 중요하다
    - 렌더 프롭 패턴은 서버에서 사용 불가 (함수 직렬화 못함)
  - 부작용이 있는 훅 금지
    - useRef 훅은 사용 가능
  - 상태는 동일하지 않다
    - 서버의 상태가 여러 클라이언트에 공유될 수 있는 위험 존재
  - 클라이언트 컴포넌트는 서버 컴포넌트를 가져올 수 없다
    - 클라이언트 컴포넌트로 서버 컴포넌트 래핑하면 사용은 가능, 번들러는 import문 검사만 함
  - 클라이언트 컴포넌트는 나쁘지 않다
- 서버 액션
  - 'use server', 클라이언트 코드에서 서버 함수를 호출할 수 있게 해주는 리액트의 강력한 새 기능
  - 폼과 데이터 조작
  - 폼 외부
- 정리
  - 리액트 서버 컴포넌트
  - 컴포넌트 -> 데이터 인자(prop - 외부 데이터, state - 내부 데이터)를 받아서 -> return JSX하는 함수
  - 클라이언트 컴포넌트 렌더링 -> jsx가 babel을 통해 트랜스파일되어 -> ReactElement가 됨 -> JS 객체 안에 DOM 표현 정보들을 담고 있음
    - 리액트 엘리먼트 -> 파이버 노드로 확장되고, Virtual DOM의 노드임, Virtual DOM은 파이버 노드로 구성된 트리임, VDOM이 실제 DOM에 반영됨
  - 서버 컴포넌트 렌더링
    - rendering work -> chunk로 split됨
      - 기준: Route Segment, Suspense Boundary 이 두가지 기준으로 chunk로 split됨
    - 서버단
      1. React: 서버 컴포넌트를 RSC Payload로 렌더링함
      - RSC Payload에는 서버 컴포넌트 rendered result / 빈자리 표시 (플레이스홀더) - 클라이언트 자바스크립트 렌더링 위치, ref / props (sc -> cc)
      2. Next.js: RSC Payload + 클라이언트 컴포넌트 JS Instructions -> HTML 렌더링
    - 클라이언트단
      1. HTML 즉시 show (preview of the routes)
      2. RSC Payload를 가지고 Reconcile -> React 클라이언트 컴포넌트 + 서버 컴포넌트 트리 구성, placeholder 빈자리 채우고 DOM 업데이트
      3. 하이드레이트 - JS 인스트럭션 가지고 인터랙션 가능해짐
